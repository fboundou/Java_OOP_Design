package RecommendationEngine_Template_Method;

import java.util.*;

/*
Concrete Implementation
Here we implement the math. 
In a real AI/ML system, these vectors are often generated by embedding models 
(like Word2Vec or BERT), but the Java logic remains the same.
*/

// 2. Concrete Class: Vector-Based Similarity
public class VectorSpaceRecommender extends RecommenderEngine {

    @Override
    protected List<CompanyProfile> preFilter(CompanyProfile target, List<CompanyProfile> candidates) {
        // Optimization: Don't compare a Seed stage startup with Microsoft
        // Return only candidates within 10x revenue range (simplified)
        return candidates; 
    }

    @Override
    protected double calculateSimilarity(CompanyProfile target, CompanyProfile candidate) {
        return cosineSimilarity(target.featureVector, candidate.featureVector);
    }

    // The Mathematical Core
    private double cosineSimilarity(double[] vectorA, double[] vectorB) {
        double dotProduct = 0.0;
        double normA = 0.0;
        double normB = 0.0;

        if (vectorA.length != vectorB.length) {
            throw new IllegalArgumentException("Vectors must be of same dimension");
        }

        for (int i = 0; i < vectorA.length; i++) {
            dotProduct += vectorA[i] * vectorB[i];
            normA += Math.pow(vectorA[i], 2);
            normB += Math.pow(vectorB[i], 2);
        }

        if (normA == 0 || normB == 0) return 0.0; // Prevent division by zero

        return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
    }
}
